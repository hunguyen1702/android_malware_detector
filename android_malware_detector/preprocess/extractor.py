import os
import re
import time
import shutil
import subprocess
from threading import Thread
from xml.dom.minidom import Element
from androguard.core.bytecodes import apk


class APKExtractorThread(Thread):
    def __init__(self, path, op_dir='./', tmp_dir='./'):
        Thread.__init__(self)
        try:
            self.to_dir = op_dir
            self.path = path
            self.tmp_dir = tmp_dir
            self.app = apk.APK(self.path)
        except Exception, e:
            print '[ERROR] Cannot init thread to extract raw data from {}. {}'.format(path, e)
            return

    def __generate_path(self, smali_path):
        try:
            for root_dir, sub_dirs, file_names in os.walk(smali_path):
                for file_name in file_names:
                    if file_name.endswith('.smali'):
                        yield os.path.join(root_dir, file_name)
        except Exception, e:
            print '[ERROR] Cannot generate path from {}. {}'.format(smali_path, e)
            return

    def __generate_file_line(self, fp):
        try:
            with open(fp, 'r') as f:
                for line in f:
                    yield line
        except IOError, e:
            print '[ERROR] Cannot read file {}. {}'.format(fp, e)
            return
        except Exception, e:
            print '[ERROR] Cannot read file. {}'.format(e)
            return

    def extract_permission(self):
        try:
            perms = self.app.get_permissions()
            perms = sorted(list(set(perms)))
            perms = filter(lambda perm: re.search(r'^android', perm) is not None, perms)
            perms = map(lambda perm: "permission::" + perm, perms)
        except Exception, e:
            print "[ERROR] Cannot extract permission. {}".format(e)
            return
        return perms

    def extract_intent(self):
        intents = []
        try:
            manifest = self.app.get_android_manifest_xml()
            for element in manifest.getElementsByTagName('intent-filter'):
                for item in element.childNodes:
                    if isinstance(item, Element):
                        intent = item.getAttribute('android:name')
                        intents.append(intent)
            intents = sorted(list(set(intents)))
            intents = filter(lambda it: re.search(r'^android', it) is not None, intents)
            intents = map(lambda it: "intent::" + it, intents)
        except Exception, e:
            print "[ERROR] Cannot extract intent. {}".format(e)
            return
        return intents

    def extract_classes_names(self, smali_path):
        classes_names = []
        try:
            for smali_file in self.__generate_path(smali_path):
                for item in self.__generate_file_line(smali_file):
                    if '.class' in item:
                        match = re.search(r'(L[^;]+;)', item)
                        if match is not None:
                            classes_names.append(match.group(1))
        except Exception, e:
            print '[ERROR] Cannot extract classes names from apk. {}'.format(e)
            return
        return classes_names

    def extract_api(self, fp):
        apis = []
        try:
            fn = os.path.basename(fp)
            tmp_dir = os.path.join(self.tmp_dir, 'amd_{}_{}'.format(int(time.time()), fn))
            subprocess.call('apktool d \"' + fp + '\" -o \"' + tmp_dir + '\"', shell=True)
            smali_path = tmp_dir
            classes_names = self.extract_classes_names(smali_path)
            for smali_file in self.__generate_path(smali_path):
                for item in self.__generate_file_line(smali_file):
                    match = re.search(r'(L(android|java|javax)[^$;]*;)->[^(]*\([^)]*\).*', item)
                    if match and match.group(1) not in classes_names and '/' in match.group(1):
                        api = re.sub('/', '.', match.group(1))
                        api = api[1:len(api) - 1]
                        apis.append(api)
            apis = sorted(list(set(apis)))
            apis = map(lambda a: "api::" + a, apis)
            shutil.rmtree(tmp_dir)
        except Exception, e:
            print '[ERROR] Cannot extract api from file {}. {}'.format(fp, e)
            return
        return apis

    def extract_raw_data(self):
        print "[INFO] Extract raw data from {}".format(self.path)
        raw_data = []
        try:
            print "[INFO] Extract permissons from {}".format(self.app.get_package())
            raw_data.extend(self.extract_permission())
            print "[INFO] Extract intents from {}".format(self.app.get_package())
            raw_data.extend(self.extract_intent())
            print "[INFO] Extract apis from {}".format(self.app.get_package())
            raw_data.extend(self.extract_api(self.path))
        except TypeError, e:
            print "[ERROR] Cannot extract raw data from file: {}. {}".format(self.path, e)
            return
        except Exception, e:
            print "[ERROR] Cannot extract raw data from file. {}".format(e)
            return
        return raw_data

    def save_raw_data(self, fn, raw_data):
        op_file_path = os.path.join(self.to_dir, fn)
        print "[INFO] Saving raw data to {}".format(op_file_path)
        with open(op_file_path, 'w') as f:
            f.write('\n'.join(raw_data))

    def run(self):
        print "[INFO] Starting thread to extract raw data"
        if not os.path.isfile(self.path):
            print "[ERROR] This path {} is not a valid file path."
            return
        raw_data = self.extract_raw_data()
        if not raw_data:
            print "[ERROR] Cannot extract raw data from file {}".format(self.path)
            return
        op_file_name = os.path.basename(self.path) + '.txt'
        self.save_raw_data(op_file_name, raw_data)


class APKExtractor(object):
    def __init__(self, path, op_dir='./', num_thread=1, tmp_dir='./'):
        try:
            self.path = path
            self.to_dir = op_dir
            self.num_thread = num_thread
            self.tmp_dir = tmp_dir
            self.thread_pool = []
        except Exception, e:
            print '[ERROR] Cannot init extractor. {}'.format(e)

    def wait(self):
        try:
            for th in self.thread_pool:
                th.join()
            self.thread_pool = []
        except Exception:
            return

    def start_thread(self, path):
        try:
            th = APKExtractorThread(path, self.to_dir, self.tmp_dir)
            th.start()
            self.thread_pool.append(th)
        except Exception:
            return

    def is_exeed(self):
        return len(self.thread_pool) == self.num_thread

    def __generate_file_list(self):
        try:
            file_names = os.listdir(self.path)
            existed_file = os.listdir(self.to_dir)
            existed_file = map(lambda a: os.path.splitext(a)[0], existed_file)
            file_names = filter(lambda a: a not in existed_file, file_names)
            for file_name in file_names:
                yield os.path.join(self.path, file_name)
        except Exception:
            return

    def run_extractor(self):
        print "[INFO] Starting extractor with {} thread(s)".format(self.num_thread)
        if not (os.path.exists(self.to_dir) and os.path.isdir(self.to_dir)):
            print "[ERROR] The output directory is invalid"
            return
        if os.path.isdir(self.path):
            for file_name in self.__generate_file_list():
                if self.is_exeed():
                    self.wait()
                self.start_thread(file_name)
            self.wait()
        elif os.path.isfile(self.path):
            self.start_thread(self.path)
            self.wait()
        else:
            print '[ERROR] The path you specify is not valid file path or folder. Please try again'

    @staticmethod
    def extract(fp, tmp_dir='./'):
        th = APKExtractorThread(fp, tmp_dir)
        raw_data = th.extract_raw_data()
        return raw_data
